#######################################################################
#                            Rust Snippets                            #
#######################################################################

priority -50

snippet l "let variable declaration with type inference"
	let ${1} = ${2};
endsnippet
snippet lt "let variable declaration with explicit type annotation"
	let ${1}: ${2} = ${3};
endsnippet
snippet lm "let mut variable declaration with type inference"
	let mut ${1} = ${2};
endsnippet
snippet ltm "let mut variable declaration with explicit type annotation"
	let mut ${1}: ${2} = ${3};
endsnippet
snippet s "struct" b
struct ${1:Name}
endsnippet

snippet sp "#[should_panic]" b
#[should_panic${1:(expected = ${2:"Divide result is zero"})}]
$0
endsnippet

snippet dead "Allow dead code" b
#[allow(dead_code)]
endsnippet

snippet test "#[cfg(test)]" b
#[cfg(test)]
endsnippet

snippet testfn "#[test]" b
#[test]
fn ${1:function_name}(${2})${3/..*/ -> /}${3} {
	${VISUAL}${0}
}
endsnippet

snippet main "main fn" b
fn main() {
	$0
}
endsnippet
snippet u
use $0;
endsnippet

snippet match
match ${1:result} {
	$0
}
endsnippet

snippet Ok
Ok(${1:n}) => $0,
endsnippet

snippet Err
Err(why) => $0,
endsnippet

snippet #
#[$0]
endsnippet

snippet d
#[derive(${1:Debug}${2:, ${3:Clone}})]
endsnippet

snippet dis
impl fmt::Display for ${1:DoubleError} {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "invalid first item to double")
    }
}
endsnippet

snippet fn "A function, optionally with arguments and return type."
fn ${1:function_name}(${2})${3/..*/ -> /}${3} {
	${VISUAL}${0}
}
endsnippet

snippet pfn "A public function, optionally with arguments and return type."
pub fn ${1:function_name}(${2})${3/..*/ -> /}${3} {
	${VISUAL}${0}
}
endsnippet

snippet arg "Function Arguments" i
${1:a}: ${2:T}${3:, arg}
endsnippet

snippet c "Closure, anonymous function (inline)" i
${1:move }|${2}| $3
endsnippet

snippet |} "Closure, anonymous function (block)" i
${1:move }|${2}| {$3}
endsnippet

snippet pri "print!(..)" b
print!("${1}"${2/..*/, /}${2});
endsnippet

snippet pln "println!(..)" b
println!("${1}"${2/..*/, /}${2});
endsnippet

snippet fmt "format!(..)"
format!("${1}"${2/..*/, /}${2});
endsnippet

snippet macro "macro_rules!" b
macro_rules! ${1:name} (
	(${2:matcher}) => (
		${3}
	)
)
endsnippet

snippet mod "A module" b
mod ${1:`!p snip.rv = snip.basename.lower() or "name"`} {
	${VISUAL}${0}
}
endsnippet

snippet for "for .. in .." b
for ${1:i} in ${2} {
	${VISUAL}${0}
}
endsnippet

snippet todo "A Todo comment"
// [TODO]: ${1:Description} - `!v strftime("%Y-%m-%d %I:%M%P")`
endsnippet

snippet st "Struct" b
struct ${1:`!p snip.rv = snip.basename.title() or "Name"`} {
	${VISUAL}${0}
}
endsnippet

# TODO: fancy dynamic field mirroring like Python slotclass
snippet stn "Struct with new constructor." b
pub struct ${1:`!p snip.rv = snip.basename.title() or "Name"`} {
	fd${0}
}

impl $1 {
	pub fn new(${2}) -> $1 {
		$1 { ${3} };
	}
}
endsnippet

snippet fd "Struct field definition" w
${1:name}: ${2:Type},
endsnippet

snippet impl "Struct/Trait implementation" b
impl ${1:Type/Trait}${2: for ${3:Type}} {
	${0}
}
endsnippet

snippet dead
	#![allow(dead_code)]
endsnippet

# small parts
snippet u "use"
	use $0
endsnippet
# Functions
snippet fn "Function definition"
	fn ${1:function_name}(${2})${3} {
		${0}
	}
endsnippet
snippet pfn "Function definition"
	pub fn ${1:function_name}(${2})${3} {
		${0}
	}
endsnippet
snippet test "Unit test function"
	#[test]
	fn ${1:test_function_name}() {
		${0}
	}
endsnippet
snippet bench "Bench function" b
	#[bench]
	fn ${1:bench_function_name}(b: &mut test::Bencher) {
		b.iter(|| {
			${0}
		})
	}
endsnippet
snippet new "Constructor function"
	pub fn new(${2}) -> ${1:Name} {
		$1 { ${3} }
	}
endsnippet
snippet pri "print!"
	print!("${1}");
endsnippet
snippet pri, "print! with format param"
	print!("${1}{${2}}", ${3});
endsnippet
snippet fmt "format!"
	format!("${1}{${2}}", ${3});
endsnippet

# Modules
snippet ec "extern crate"
	extern crate ${1:sync};
endsnippet
snippet ecl "extern crate log"
	#[macro_use]
	extern crate log;
endsnippet
snippet mod
	mod ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} {
		${0}
	} /* $1 */
endsnippet
snippet testmod "Test module" b
	#[cfg(test)]
	mod tests {
		use super::${1:*};

		test${0}
	}
endsnippet
# Attributes
snippet allow "allow lint attribute" b
	#[allow(${1:unused_variable})]
endsnippet
snippet cfg "cfg attribute" b
	#[cfg(${1:target_os = "linux"})]
endsnippet
snippet feat "feature attribute" b
	#![feature(${1:plugin})]
endsnippet
snippet der "#[derive(..)]" b
	#[derive(${1:Debug})]
endsnippet
snippet attr "#[..]" b
	#[${1:inline}]
endsnippet
snippet crate "Define create meta attributes"
	// Crate name
	#![crate_name = "${1:crate_name}"]
	// Additional metadata attributes
	#![desc = "${2:Descrption.}"]
	#![license = "${3:BSD}"]
	#![comment = "${4:Comment.}"]
	// Specify the output type
	#![crate_type = "${5:lib}"]
endsnippet
# Common types
snippet opt "Option<T>"
	Option<${1:i32}>
endsnippet
snippet res "Result<T, E>"
	Result<${1:~str}, ${2:()}>
endsnippet
# Control structures
snippet if
	if ${1} {
		${0:${VISUAL}}
	}
endsnippet
snippet ife "if / else"
	if ${1} {
		${2:${VISUAL}}
	} else {
		${0}
	}
endsnippet
snippet el "else"
	else {
		${0:${VISUAL}}
	}
endsnippet
snippet eli "else if"
	else if ${1} {
		${0:${VISUAL}}
	}
endsnippet
snippet mat "match pattern"
	match ${1} {
		${2} => ${3}
	}
endsnippet
snippet case "Case clause of pattern match"
	${1:_} => ${2:expression}
endsnippet
snippet loop "loop {}" b
	loop {
		${0:${VISUAL}}
	}
endsnippet
snippet wh "while loop"
	while ${1:condition} {
		${0:${VISUAL}}
	}
endsnippet
snippet for "for ... in ... loop"
	for ${1:i} in ${2} {
		${0}
	}
endsnippet
# TODO commenting
snippet todo "TODO comment"
	// [TODO]: ${0:Description}
endsnippet
snippet fixme "FIXME comment"
	// FIXME: $0
endsnippet
# Struct
snippet st "Struct definition"
	struct ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} {
		${0}
	}
endsnippet
snippet impl "Struct/Trait implementation"
	impl ${1:Type/Trait}${2: for ${3:Type}} {
		${0}
	}
endsnippet
snippet stn "Struct with new constructor"
	pub struct ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} {
		${0}
	}

	impl $1 {
		pub fn new(${2}) -> Self {
			$1 { ${3} }
		}
	}
endsnippet
snippet type "Type alias"
	type ${1:NewName} = $2;
endsnippet
snippet enum "enum definition"
	enum ${1:Name} {
		${2},
	}
endsnippet
# Traits
snippet trait "Trait definition"
	trait ${1:Name} {
		${0}
	}
endsnippet
snippet drop "Drop trait implementation (destructor)"
	impl Drop for ${1:Name} {
		fn drop(&mut self) {
			${0}
		}
	}
endsnippet
# Statics
snippet ss "static string declaration"
	static ${1}: &'static str = "${0}";
endsnippet
snippet stat "static item declaration"
	static ${1}: ${2:usize} = ${0};
endsnippet
# Concurrency
snippet scoped "spawn a scoped thread"
	thread::scoped(${1:move }|| {
		${0}
	});
endsnippet
snippet spawn "spawn a thread"
	thread::spawn(${1:move }|| {
		${0}
	});
endsnippet
snippet chan "Declare (Sender, Receiver) pair of asynchronous channel()"
	let (${1:tx}, ${2:rx}): (Sender<${3:i32}>, Receiver<${4:i32}>) = channel();
endsnippet
# Testing
snippet as "assert!"
	assert!(${1:predicate});
endsnippet
snippet ase "assert_eq!"
	assert_eq!(${1:expected}, ${2:actual});
# Implementations
endsnippet
snippet asref "AsRef trait implementation"
	impl AsRef<${1:Ref}> for ${2:Type} {
		fn as_ref(&self) -> &${3:$1} {
			&self.${0:field}
		}
	}
endsnippet
snippet asmut "AsMut trait implementation"
	impl AsMut<${1:Ref}> for ${2:Type} {
		fn as_mut(&mut self) -> &mut ${3:$1} {
			&mut self.${0:field}
		}
	}
endsnippet

# vim:ft=snippets:
